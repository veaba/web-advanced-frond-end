<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 进阶web高级前端知识体系</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="面对web技术全栈，来自@veaba 个人学习笔记以及公开博客文章整理">
    
    <link rel="preload" href="/assets/css/0.styles.cbd9db94.css" as="style"><link rel="preload" href="/assets/js/app.da650921.js" as="script"><link rel="preload" href="/assets/js/2.cfea43a3.js" as="script"><link rel="preload" href="/assets/js/94.02ba3e23.js" as="script"><link rel="prefetch" href="/assets/js/10.5da23f4b.js"><link rel="prefetch" href="/assets/js/11.d3d1c83e.js"><link rel="prefetch" href="/assets/js/12.772613d1.js"><link rel="prefetch" href="/assets/js/13.ec49721a.js"><link rel="prefetch" href="/assets/js/14.fc6e206d.js"><link rel="prefetch" href="/assets/js/15.009cf3b0.js"><link rel="prefetch" href="/assets/js/16.dadbfe99.js"><link rel="prefetch" href="/assets/js/17.79c44708.js"><link rel="prefetch" href="/assets/js/18.2375a03f.js"><link rel="prefetch" href="/assets/js/19.fe5ed694.js"><link rel="prefetch" href="/assets/js/20.917a5ffd.js"><link rel="prefetch" href="/assets/js/21.8c6475b6.js"><link rel="prefetch" href="/assets/js/22.bde4e132.js"><link rel="prefetch" href="/assets/js/23.f8f70e9d.js"><link rel="prefetch" href="/assets/js/24.293d44a6.js"><link rel="prefetch" href="/assets/js/25.7cae75c1.js"><link rel="prefetch" href="/assets/js/26.5a683528.js"><link rel="prefetch" href="/assets/js/27.49a4c6c1.js"><link rel="prefetch" href="/assets/js/28.2133b4b3.js"><link rel="prefetch" href="/assets/js/29.6ad131c0.js"><link rel="prefetch" href="/assets/js/3.ca39d2c1.js"><link rel="prefetch" href="/assets/js/30.c4ca3815.js"><link rel="prefetch" href="/assets/js/31.73efc52f.js"><link rel="prefetch" href="/assets/js/32.b4e6b601.js"><link rel="prefetch" href="/assets/js/33.8c360491.js"><link rel="prefetch" href="/assets/js/34.0c827d92.js"><link rel="prefetch" href="/assets/js/35.49038485.js"><link rel="prefetch" href="/assets/js/36.0f8b4f9f.js"><link rel="prefetch" href="/assets/js/37.9a886783.js"><link rel="prefetch" href="/assets/js/38.e2af7986.js"><link rel="prefetch" href="/assets/js/39.c6d05eb2.js"><link rel="prefetch" href="/assets/js/4.2363fb5a.js"><link rel="prefetch" href="/assets/js/40.a8d0f478.js"><link rel="prefetch" href="/assets/js/41.140516a4.js"><link rel="prefetch" href="/assets/js/42.68724ce8.js"><link rel="prefetch" href="/assets/js/43.e122cb8e.js"><link rel="prefetch" href="/assets/js/44.b9df3e9d.js"><link rel="prefetch" href="/assets/js/45.aa7e9f09.js"><link rel="prefetch" href="/assets/js/46.0ff412aa.js"><link rel="prefetch" href="/assets/js/47.d010025d.js"><link rel="prefetch" href="/assets/js/48.4aab68ce.js"><link rel="prefetch" href="/assets/js/49.9112a8d5.js"><link rel="prefetch" href="/assets/js/5.1a17c7fd.js"><link rel="prefetch" href="/assets/js/50.66213575.js"><link rel="prefetch" href="/assets/js/51.7c28b94d.js"><link rel="prefetch" href="/assets/js/52.b994f2a5.js"><link rel="prefetch" href="/assets/js/53.cb8ae75f.js"><link rel="prefetch" href="/assets/js/54.bed231f5.js"><link rel="prefetch" href="/assets/js/55.b5c12083.js"><link rel="prefetch" href="/assets/js/56.d24c194a.js"><link rel="prefetch" href="/assets/js/57.2266c999.js"><link rel="prefetch" href="/assets/js/58.45dbc100.js"><link rel="prefetch" href="/assets/js/59.ee7c29b0.js"><link rel="prefetch" href="/assets/js/6.f5721c6c.js"><link rel="prefetch" href="/assets/js/60.49ed42de.js"><link rel="prefetch" href="/assets/js/61.a43df18c.js"><link rel="prefetch" href="/assets/js/62.5e1da83b.js"><link rel="prefetch" href="/assets/js/63.14208060.js"><link rel="prefetch" href="/assets/js/64.6b19c853.js"><link rel="prefetch" href="/assets/js/65.ceab9cdd.js"><link rel="prefetch" href="/assets/js/66.b753dfad.js"><link rel="prefetch" href="/assets/js/67.1db0c319.js"><link rel="prefetch" href="/assets/js/68.f5f93361.js"><link rel="prefetch" href="/assets/js/69.b1ab7abf.js"><link rel="prefetch" href="/assets/js/7.8d5cc4a4.js"><link rel="prefetch" href="/assets/js/70.77a5f0d2.js"><link rel="prefetch" href="/assets/js/71.eb7e60d3.js"><link rel="prefetch" href="/assets/js/72.ce397162.js"><link rel="prefetch" href="/assets/js/73.d6d6e81e.js"><link rel="prefetch" href="/assets/js/74.b3461251.js"><link rel="prefetch" href="/assets/js/75.9b07dfb3.js"><link rel="prefetch" href="/assets/js/76.e2e72906.js"><link rel="prefetch" href="/assets/js/77.e136d187.js"><link rel="prefetch" href="/assets/js/78.3171be39.js"><link rel="prefetch" href="/assets/js/79.14b82bd4.js"><link rel="prefetch" href="/assets/js/8.7fa854ee.js"><link rel="prefetch" href="/assets/js/80.79b8c166.js"><link rel="prefetch" href="/assets/js/81.b2f0ea0e.js"><link rel="prefetch" href="/assets/js/82.3144efdf.js"><link rel="prefetch" href="/assets/js/83.5634923a.js"><link rel="prefetch" href="/assets/js/84.703bfdd4.js"><link rel="prefetch" href="/assets/js/85.d32675d6.js"><link rel="prefetch" href="/assets/js/86.14b93fe4.js"><link rel="prefetch" href="/assets/js/87.e5260d6a.js"><link rel="prefetch" href="/assets/js/88.46bb29a0.js"><link rel="prefetch" href="/assets/js/89.50521f1a.js"><link rel="prefetch" href="/assets/js/9.cfef67a1.js"><link rel="prefetch" href="/assets/js/90.2d1b8a1d.js"><link rel="prefetch" href="/assets/js/91.038004a9.js"><link rel="prefetch" href="/assets/js/92.5b384f19.js"><link rel="prefetch" href="/assets/js/93.3c44828a.js"><link rel="prefetch" href="/assets/js/95.9c339ca0.js"><link rel="prefetch" href="/assets/js/96.bdf4adbb.js"><link rel="prefetch" href="/assets/js/97.18abbb4d.js"><link rel="prefetch" href="/assets/js/98.4530f6df.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cbd9db94.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/favicon.png" alt="进阶web高级前端知识体系" class="logo"> <span class="site-name can-hide">进阶web高级前端知识体系</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/" class="nav-link">指南</a></div><div class="nav-item"><a href="/rust/actix-web/" class="nav-link">actix-web</a></div><div class="nav-item"><a href="/javascript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/node/" class="nav-link">Node</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div> <a href="https://github.com/veaba/web-advanced-frond-end" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/" class="nav-link">指南</a></div><div class="nav-item"><a href="/rust/actix-web/" class="nav-link">actix-web</a></div><div class="nav-item"><a href="/javascript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/node/" class="nav-link">Node</a></div><div class="nav-item"><a href="/interview/" class="nav-link">面试题</a></div> <a href="https://github.com/veaba/web-advanced-frond-end" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue</span> <span title="实验！" class="icon-experiment" style="display:none;"></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/vue2.html#疑问点" class="sidebar-link">疑问点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2.html#vue-基础知识" class="sidebar-link">vue 基础知识</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2.html#api" class="sidebar-link">api</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2.html#vue-cli-3-0" class="sidebar-link">vue-cli 3.0</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue2.html#开发者注意以下问题" class="sidebar-link">开发者注意以下问题</a></li></ul></li><li><a href="/vue/vue2.html#vue-router-路由" class="sidebar-link">vue-router  路由</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2.html#vue-相关面试题" class="sidebar-link">vue 相关面试题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2.html#基于vue-cli-3-0-demo项目框架" class="sidebar-link">基于vue-cli 3.0 demo项目框架</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2.html#vue源码学习" class="sidebar-link">vue源码学习</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue2.html#vue3-0-先占坑" class="sidebar-link">vue3.0 先占坑</a></li><li class="sidebar-sub-header"><a href="/vue/vue2.html#启动" class="sidebar-link">启动</a></li><li class="sidebar-sub-header"><a href="/vue/vue2.html#源码项目结构" class="sidebar-link">源码项目结构</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="content-layout"><div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h1> <ul><li><a href="/vue/vue2-api/">更多关于VUE API人工整理手记，见 /docs/vue-api.md @veaba</a></li></ul> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>send<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
{{message}}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span><span class="token string">&quot;#app&quot;</span><span class="token punctuation">,</span><span class="token comment">/*可以是class？*/</span>
  data<span class="token operator">:</span><span class="token punctuation">{</span>
    message<span class="token operator">:</span><span class="token string">&quot;hello world!&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token operator">=</span><span class="token string">&quot;change something ha?&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="疑问点"><a href="#疑问点" class="header-anchor">#</a> 疑问点</h2> <ul><li>vue 里面的打补丁 扮演何种角色？</li> <li>vue如何处理定时器或者销毁定时器的？</li></ul> <blockquote><p>在<code>beforeDestroy</code>里面处理</p></blockquote> <div class="language-ecmascript 6 extra-class"><pre class="language-text"><code>export default {
	
  data(){
    return {
      second:5,
      timer:null
    }
  },
  mounted:function(){
    this.timer=setInterval(()=&gt;{
      if(this.second===0) this.backPre();
      else this.second--
    },1000)
  },
  beforeDestroy(){
    clearInterval(this.timer)
  },
  methods:{
    backPre(){
      return 'Do you want what me to do,ha?'
    }
  }
}

</code></pre></div><h2 id="vue-基础知识"><a href="#vue-基础知识" class="header-anchor">#</a> vue 基础知识</h2> <table><thead><tr><th>英文</th> <th>建议翻译</th></tr></thead> <tbody><tr><td>observe/observer</td> <td>侦听/侦听器</td></tr> <tr><td>watch/watcher</td> <td>侦听/侦听器</td></tr> <tr><td>subs</td> <td>订阅</td></tr> <tr><td>patch</td> <td>打补丁？</td></tr> <tr><td>deps</td> <td>依赖关系</td></tr></tbody></table> <ul><li><p>Vue 响应式原理分析</p> <ul><li><p>核心 Object.defineProperty 在一个对象上定义一个新属性，修改一个对象的现有属性，并返回这个对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener noreferrer">mdn了解defineProperty<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>语法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
*@obj 要定义属性的对象
*@prop 要定义或修改的属性的名称
*@descriptor 定义或修改的属性描述符，一个对象。核心的是get/set
* get 给属性提供一个getter方法，访问该属性则触发getter方法
* set 给属性提供一个setter方法，当对属性修改时触发setter方法
*/</span> 
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>prop<span class="token punctuation">,</span>descriptor<span class="token punctuation">)</span>
  
</code></pre></div><ul><li>一旦对象拥有了getter和setter，可以认为这个对象是响应式对象</li></ul></li> <li><p>vue 把什么对象变成响应式对象?</p> <ul><li>initState。初始化就是props、data变成响应式对象
<ul><li>_init 方法执行时候，会执行initState(vm)方法，定义在src/core/instance/state.js</li> <li>initProps</li> <li>initMethods</li> <li>initData</li> <li>initComputed</li> <li>initWatch</li></ul></li></ul></li> <li><p>proxy 代理</p> <ul><li>作用时将props 和data上的属性都代理到vm实例上。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> comP<span class="token operator">=</span><span class="token punctuation">{</span>
  props<span class="token operator">:</span><span class="token punctuation">{</span>
    msg<span class="token operator">:</span><span class="token string">&quot;hello&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">/*
      *@desc  say函数通过this.msg访问到定义在props上的msg，这个过程就发生在proxy
      */</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> sharePropertyfinition<span class="token operator">=</span><span class="token punctuation">{</span>
  enumerable<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
  configurable<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
  get<span class="token operator">:</span>noop<span class="token punctuation">,</span>
  set<span class="token operator">:</span>noop
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token comment">/*
 *@desc proxy函数
 *@desc 通过Object.defineProperty 把target[sourceKey][key]读写变成target[key]
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>sourceKey<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  sharePropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">get</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">proxyGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  sharePropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">set</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">proxySetter</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>val
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>sharePropertyDefinition<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li><p>observe</p> <ul><li>监测数据的变化，定义在src/core/observer/index.js</li> <li>给非vnode对象类型数据添加一个Observer，添加或已有返回，否则满足一定情况下，实例化一个？Observer对象实例</li></ul></li> <li><p>getter: 依赖收集</p> <ul><li>const dep = new Dep() 实例化一个Deo的的实例</li> <li>通过dep.depend 收集依赖</li> <li>Dep 整个getter依赖收集的核心</li> <li>依赖收集的目的是当这些响应式数据发送变化时，触发他们的setter的时候，能够知道通知哪些订阅者去做响应的逻辑处理，这过程叫派发更新。</li></ul></li> <li><p>setter: 派发更新。收集的目的是为了修改数据时候，对相关的依赖派发更新</p> <ul><li>如果shallow 为false 对新设置的值变化成一个响应式对象</li> <li>dep.notify()通知所有订阅者。
<ul><li>遍历所有订阅者subs，也就是watcher的实例数组，然后调用watcher的update方法</li> <li>queueWatcher  放在nextTick队列，等待flushSchedulerQueue
<ul><li>flushSchedulerQueue 队列排序。
<ul><li>先父到子</li> <li>用户watcher 优先render watcher</li> <li>执行期间被销毁则跳过</li></ul></li> <li>flushSchedulerQueue 队列遍历
<ul><li>watcher.run()每次都是queue.length求值。
<ul><li>this.getAndInvoke方法，并传入watcher的回调函数。</li></ul></li></ul></li> <li>状态恢复。
<ul><li>resetSchedulerState  函数。
<ul><li>变量恢复到初始值，清空watcher队列</li></ul></li></ul></li></ul></li></ul></li></ul></li> <li><p>Dep</p> <ul><li>一个依赖就是一个watcher</li> <li>是一个class，有一个target静态属性，全局唯一Watcher,被认为是一个巧妙的设计，保证同一时间只有一个全局的watcher被计算。另外自身属性subs 也是watcher的数组。
<ul><li>Dep 是watcher的一种管理，脱离watcher单独存在没有意义</li> <li>触发getter时候，会调用dep.depend()方法，也会执行Dep.target.addDep(this)</li> <li>Dep.target已经被赋值为渲染watcher，会执行addDep方法，保证同一数据不会被添加多次。执行dep.addSub(this)，执行this.subs.push(sub)。把watcher订阅到这个数据持有的dep的subs中，为后续数据变化时候能通知到哪些subs做准备</li> <li>完成依赖收集之后，再递归访问value，触发所有子项的getter—— popTarget()</li> <li>Dep.target=targetStack.pop() 返回成上一个状态，因为当前vm的数据依赖收集已完成。对应的Dep.target也需要改变，最后执行this.cleanUpDeps()</li> <li>this.cleanUpDeps()
<ul><li>变量deps，移除对dep的订阅。交换newDepIds 和depIds，newDeps和deps，并把newDepIds和newDeps清空</li></ul></li></ul></li></ul></li> <li><p>defineReactive 方法</p> <ul><li>定义一个响应式对象，给对象添加getter/setter，src/core/observer/index中</li> <li>初始化Dep对象实例</li> <li>对子对象递归调用observe方法，保证无论访问多少层的属性都能触发getter/setter</li> <li>最后利用Object.defineProperty方法对obj属性的key 添加getter/setter</li></ul></li> <li><p>Observer 通过Object.defineProperty实现对属性变化的监听。</p> <ul><li>是一个类</li> <li>作用是，给对象的属性添加一个getter、setter，用于依赖收集和派发更新</li> <li>构造函数逻辑：实例化Dep对象</li> <li>为对象添加一个__ob__属性，调用def(封装的Object.defineProperty)</li> <li>对value判断
<ul><li>是数。调用observeArray 方法——先遍历数组再调用observe方法</li> <li>是纯对象。调用walk方法——先
遍历对象，再调用defineReactive方法</li></ul></li></ul></li> <li><p>Watcher 订阅者。observe和compile之间，负责将变化的数据更新到视图</p> <ul><li>是一个class 。</li> <li>this.deps Watcher实例持有Dep实例的数组</li> <li>this.newDeps Watcher实例持有Dep实例的数组</li> <li>this.desIds —— this.deps id Set结构</li> <li>this.newDepIds —— this.newDeps id Set结构</li> <li>至于为什么有两个实例数组？</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">this</span><span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>depIds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li></ul></li> <li><p>生命周期，选项？？？这个在Vue构造器的传参中何种方式？</p> <ul><li>beforeCreate 实例初始化后 data observer 和event/watcher 事件配置之前被调用</li> <li>created 实例创建完成被立即调用（data observe，属性和方法的运损，watch/event事件回调），此时<code>挂载</code>还没有开始,<code>$el</code>目前不可见。当然此时也是可以通过nextTick()来取到document的</li> <li>beforeMount 挂载之前被调用，render函数首次被调用，该钩子在服务端渲染器件不被调用</li> <li>mounted <code>el</code>被新创建的<code>vm.$el</code>替换，并挂载到实例上调用，无法确保所有子组件都一起挂载。ssr不被调用。希望等到整个视图都渲染完毕，可以：</li></ul> <div class="language-ecmascript 6 extra-class"><pre class="language-text"><code>  export default {
   mounted(){
        this.$nextTick=function(){
          //拉拉
        }
      }
}
</code></pre></div><ul><li>beforeUpdate 数据更新时，发生在爱DOM<code>打补丁</code>之前，适合更新之前访问现有的DOM，如手动移除已添加的事件监听器。SSR渲染期间不可用</li> <li>updated 数据更新导致虚拟DOM重新渲染和<code>打补丁</code>，DOM已更新，无法确保所有子组件全都一起被重绘。SSR渲染器件不可用。可以这样做：</li></ul> <div class="language-ecmascript 6 extra-class"><pre class="language-text"><code>export default {
  updated(){
        this.$nextTick=function(){  
      	  // do something
  		}
      }
    }
</code></pre></div><ul><li>activated keep-alive 组件激活时被调用，SSR渲染期间不可用</li> <li>deactivated keep-alive 组件停用时调用，SSR渲染期间不可用</li> <li>beforeDestroy 实例销毁之前调用，在这一步实例依然完全可以用，SSR渲染期间不可用</li> <li>destroyed 实例销毁后被调用，调用后实例指示所有东西解绑，所有事件移除，子实例也被销毁，SSR渲染期间不可用</li> <li>errorCaptured 当捕获一个来自子孙组件的错误时被调用，(errorObj、发生错误组件实例、一个错误来源信息的字符串)，可以返回false阻止该错误向上传播</li></ul></li> <li><p>组件通信</p> <ul><li><p>父传子</p> <ul><li>$props</li></ul></li> <li><p>子传父</p> <ul><li>$emit</li></ul></li></ul></li> <li><p>api</p></li></ul> <h2 id="api"><a href="#api" class="header-anchor">#</a> api</h2> <ul><li><p>el
可以是css 选择器，可以是HTMLElement 实例<sub><a href="http://www.w3school.com.cn/xmldom/dom_htmlelement.asp" target="_blank" rel="noopener noreferrer">HTMLElement实例是什么?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></sub></p></li> <li><p>全局</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> Vue<span class="token operator">=</span><span class="token punctuation">{</span>
  <span class="token comment">//config、全局配置</span>
  config<span class="token operator">:</span><span class="token punctuation">{</span>
      silent<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token comment">//boolean 取消vue所有的日志的警告</span>
      optionMergeStrategies<span class="token operator">:</span><span class="token punctuation">{</span><span class="token function-variable function">_test</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//{[key:string]:Function}//自定义合并策略的选项</span>
      devtools<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">//生产false,允许vue-devtools检查代码</span>
      <span class="token function-variable function">errorHandle</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>vm<span class="token punctuation">,</span>info</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//默认undefined，</span>
      <span class="token function-variable function">warnHandler</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg<span class="token punctuation">,</span>vm<span class="token punctuation">,</span>trace</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//警告处理函数，开发环境下生效</span>
      ignoredElements<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//Array&lt;string|RegExp&gt; 忽略vue之外定义的元素</span>
      keyCodes<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//{ [key: string]: number | Array&lt;number&gt; }</span>
      performance<span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token comment">// true浏览器开发者工具性能跟踪</span>
      productionTip<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">//false 阻止vue启动时生成生产提示</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">//extend</span>
  extend<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//使用vue构造器创建一个子类，拓展构造器！！！</span>
  <span class="token comment">// nextTick</span>
  <span class="token function-variable function">nextTick</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// set</span>
  set<span class="token operator">:</span><span class="token punctuation">{</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//确保响应式更新</span>
  <span class="token keyword">delete</span><span class="token operator">:</span><span class="token punctuation">{</span>target<span class="token punctuation">,</span>key<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//避免被删除无法触发更新，但尽量少用它</span>
  directive<span class="token operator">:</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token punctuation">[</span>definition<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//指令</span>
  filter<span class="token operator">:</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token punctuation">[</span>defintion<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//注册或获取全局过滤器</span>
  component<span class="token operator">:</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token punctuation">[</span>definition<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//注册或获取全局组件</span>
  use<span class="token operator">:</span><span class="token punctuation">(</span>object<span class="token operator">|</span> Function<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//安装vue 插件</span>
  mixin<span class="token operator">:</span><span class="token punctuation">{</span>Object<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//混入</span>
  compile<span class="token operator">:</span><span class="token punctuation">{</span>string<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//template 编译字符</span>
  version<span class="token operator">:</span>string<span class="token comment">//版本号</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-cli-3-0"><a href="#vue-cli-3-0" class="header-anchor">#</a> vue-cli 3.0</h2> <ul><li>则选择typescript+vue的开始模式</li> <li>也支持预装</li></ul> <h3 id="开发者注意以下问题"><a href="#开发者注意以下问题" class="header-anchor">#</a> 开发者注意以下问题</h3> <ul><li>product 环境下，关闭sourceMap</li> <li>product 环境下，尽量关闭console</li> <li>配置devServer</li> <li>多页应用,会导致页面重复大一倍</li></ul> <h2 id="vue-router-路由"><a href="#vue-router-路由" class="header-anchor">#</a> vue-router  路由</h2> <ul><li>vue router 懒加载</li> <li>vue 路由的几种模式，history 和hash 的原理是什么？</li></ul> <h2 id="vue-相关面试题"><a href="#vue-相关面试题" class="header-anchor">#</a> vue 相关面试题</h2> <ul><li><p>为什么vue 的data 是一个函数?</p> <ul><li>由于js语法特性决定来使用一个函数赋值。</li></ul></li></ul> <h2 id="基于vue-cli-3-0-demo项目框架"><a href="#基于vue-cli-3-0-demo项目框架" class="header-anchor">#</a> 基于vue-cli 3.0 demo项目框架</h2> <h2 id="vue源码学习"><a href="#vue源码学习" class="header-anchor">#</a> vue源码学习</h2> <ul><li><a href="http://jiongks.name/blog/vue-code-review/" target="_blank" rel="noopener noreferrer">勾三股四 Vue.js 源码学习笔记<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener noreferrer">HcySunYang Vue2.1.7源码学习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://hcysun.me/vue-design/" target="_blank" rel="noopener noreferrer">Vue技术内幕-HcySunYang<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="noopener noreferrer">Vue.js 技术揭秘-ustbhuangyi<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="vue3-0-先占坑"><a href="#vue3-0-先占坑" class="header-anchor">#</a> vue3.0 <code>先占坑</code></h3> <blockquote><p>https://www.bilibili.com/video/av36787459/ vue-v2.5.16.js 3.0 最新进展，来自 Vue Conf 杭州</p></blockquote> <h4 id="模板编译、virtual-dom-runtime性能"><a href="#模板编译、virtual-dom-runtime性能" class="header-anchor">#</a> 模板编译、Virtual Dom runtime性能</h4> <ul><li>Virtual DOM 实现 <code>完全重构，100%，减少运行时开销（潜在），编译时来提供性能</code> <ul><li>重构原生HTML标签的判断逻辑，编译时，判断标签，在运行时生成响应的标签或组件</li> <li>生成虚拟Node，保持“形状一致”，同样个数的参数，利于JavaScript引擎优化</li> <li>运行时留下Hint，静态分析元素包含的子元素类型，以便跳过不必要分支判断</li></ul></li> <li>优化Slots 生成
<ul><li>拆分父组件和子组件的耦合关系，引入生成函数，scope、slot统一称为一个函数，由子组件决定是否调用函数，并把传入的内容分配给子组件来完成收集，避免不要的组件渲染</li> <li>真正依赖某个数据的组件，才会可能重新渲染，不存在手动优化组件过度重绘问题</li></ul></li> <li>静态内容提取
<ul><li>检测到一部分模板不会变，直接提取，在之后更新中，直接复用 Virtual dom，甚至可以在比对过程跳过整个树</li> <li>包含深度动态内容时，如果元素所有的属性都是静态的，提取属性对象，比对元素时，发现data都一样，便可跳过，去比对children即可</li></ul></li> <li>内联事件函数提取
<code>&lt;Com @event=&quot;count++&quot;&gt;</code> <ul><li>重新渲染时会生成新函数，Cache后，以便重用，避免子组件无谓更新的效果</li></ul></li></ul> <h4 id="数据监听系统"><a href="#数据监听系统" class="header-anchor">#</a> 数据监听系统</h4> <ul><li>把Object.defineProperty 改为 proxy</li> <li>全语言特性支持
<ul><li>新属性增加</li> <li>属性的删除</li> <li>数组index</li> <li>数组length 的修改</li> <li>Map</li> <li>Set</li> <li>WeakMap</li> <li>WeakSet</li> <li>大规模数据帧听性能提升</li></ul></li> <li>利用proxy 内部判断，减少组件实例初始化开销</li> <li>实测，内存减半，性能提升100%</li></ul> <h4 id="减少runtime-体积-目测测试10kb左右"><a href="#减少runtime-体积-目测测试10kb左右" class="header-anchor">#</a> 减少runtime 体积，目测测试10kb左右</h4> <ul><li>tree-shaking代码结构，按需引入 import
<ul><li>内置组件
<ul><li>keep-alive</li> <li>transition</li></ul></li> <li>指令运行时
<ul><li>v-model</li> <li>v-for</li></ul></li> <li>工具函数
<ul><li>async component</li> <li>mixins</li> <li>memoize<code>new 新的工具函数</code></li></ul></li></ul></li></ul> <h4 id="更易维护"><a href="#更易维护" class="header-anchor">#</a> 更易维护</h4> <ul><li>flow 迁移 typeScript
<ul><li>降低源码阅读能力，引入了类型信息</li> <li>内部模块解耦，如独立observer</li> <li>让更多的开发者参与进来</li></ul></li> <li>编译器重构
<ul><li>插件化设计</li> <li>带位置信息的parser（source maps）</li> <li>铺路 IDE工具链，如 vetur 作者作为vscode团队成员参与vue 3.0的开发</li></ul></li></ul> <h4 id="多端渲染支持"><a href="#多端渲染支持" class="header-anchor">#</a> 多端渲染支持</h4> <ul><li>场景
<ul><li><code>vue native</code></li> <li><code>wexx</code></li> <li><code>mpvue</code> 小程序</li></ul></li> <li>vue作为runtime编译到多端
<ul><li>独立出真正的 customer render API，在 <code>import {createRenderer} from '@vue/runtime-core'</code>，平台无关vue runtime</li> <li>vue组件和 Virtual Dom 直接渲染到元素的对象上去</li></ul></li></ul> <h4 id="响应式数据监听api"><a href="#响应式数据监听api" class="header-anchor">#</a> 响应式数据监听API</h4> <ul><li>实现跨组件的状态共享</li> <li>排查组件更新的触发原因
<ul><li>提供新的 renderTriggered API</li></ul></li></ul> <h4 id="更好的typescript-支持以及原生的class-api-和-tsx"><a href="#更好的typescript-支持以及原生的class-api-和-tsx" class="header-anchor">#</a> 更好的typeScript 支持以及原生的Class API 和 TSX</h4> <ul><li>甚至不需要babel</li></ul> <h4 id="更好的警告信息"><a href="#更好的警告信息" class="header-anchor">#</a> 更好的警告信息</h4> <ul><li>组件堆栈包含函数式组件</li> <li>可以在警告信息中查看组建的props</li> <li>在更新的警告中提供组件堆栈信息</li></ul> <h4 id="experimental-hooks-api-逻辑重用机制-可能取代mixins"><a href="#experimental-hooks-api-逻辑重用机制-可能取代mixins" class="header-anchor">#</a> Experimental Hooks API，逻辑重用机制，可能取代mixins</h4> <ul><li>Hooks 替代mixins</li> <li>Time Slicing Support 切割JavaScript 计算，一帧一帧去处理，预留每16ms yield给浏览器让用户事件重新进来，允许中间有机会让用户添加进事件</li></ul> <h4 id="关于ie"><a href="#关于ie" class="header-anchor">#</a> 关于IE</h4> <ul><li>IE11自动降级为旧的getter/setter机制</li> <li>并引入增加不支持IE的语法警告</li></ul> <h3 id="启动"><a href="#启动" class="header-anchor">#</a> 启动</h3> <div class="language-mpm extra-class"><pre class="language-text"><code>cnpm install -g karma (运行时test 是基于 Karma 的)
cnpm install --save mime-db
cnpm install (安装依赖)
cnpm run dev:test

</code></pre></div><h3 id="源码项目结构"><a href="#源码项目结构" class="header-anchor">#</a> 源码项目结构</h3> <p><a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup" target="_blank" rel="noopener noreferrer">vue官方开发文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p><code>scripts</code> 一般不需要关注，不过熟悉以下两个文件会更好</p> <ul><li><code>scripts/alias.js</code>  所有源码和测试中使用模块导入的别名</li> <li><code>scripts/config.js</code> 包含生成<code>dist/</code>的所有文件的配置，查找入口文件，都在这个<code>dist</code>都在里面</li></ul></li> <li><p><code>dist</code> 包含用户发布的内置文件。此目录只会在发布的时候更新，并不能说明当前开发的最新特性变化。</p> <ul><li>关于dist的信息请查看 <a href="https://github.com/vuejs/vue/blob/dev/dist/README.md" target="_blank" rel="noopener noreferrer">更多<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p><code>flow</code> 包含flow 的类型声明。全局加载的，可以在普通源码中看到他们在注释中的使用</p></li> <li><p><code>packages</code> 包含 vue ssr 和 vue 模板编译 包。vue的依赖包</p></li> <li><p><code>test</code> 包含所有测试。单元测试是Jasmine写的，运行是用Karma。e2e 是Nighwatch.js 编写和运行的。</p></li> <li><p><code>src</code> 包含源代码。基本代码是es2015编写的，并用flow 来做类型注释</p> <ul><li><code>compiler</code> 编译器。包含模板转函数编译器的代码。</li> <li><code>parse</code> 解析器（将字符串模板转为抽象语法树AST）</li> <li><code>optimizer</code> 优化器（检测用于<code>vdom</code>呈现优化的静态树）</li> <li><code>code generator</code>代码生成器（将抽象语法树生成渲染函数代码）</li></ul> <p>代码生成器直接从抽象语法树生成字符串，这样做的代码规格较小，因为编译器在独立构建中，发送给浏览器的</p> <ul><li><code>core</code> 包含通用，无关平台运行时的代码。
<ul><li>vue2.0开始 core 就与平台无关。这意味着，你可以运行在浏览器、nodejs、或者嵌入式js里面。</li> <li><code>observer</code> 观察者。包含与响应式系统相关的代码。</li> <li><code>vdom</code> 虚拟dom。 包含虚拟dom 创建元素的相关代码和补丁。</li> <li><code>instance</code> 实例。包含Vue 实例构造函数和原型对象(prototype)方法。</li> <li><code>global-api</code> 顾名思义，就是全局的api</li> <li><code>components</code> 通过抽象组件，目前 keep-alive 是唯一的一个。</li></ul></li> <li><code>server</code>　包含ssr（服务端渲染 server-side rendering）相关代码</li> <li><code>platforms</code> 包含特定平台的代码。</li></ul> <p>来自 <code>dist/build</code>的入口文件位于各自平台的目录中。
每个平台模块包含三个部分：编译器compiler、运行时runtime、服务器server。对应上面的三个目录，每个部分都包含特定的平台的 模块/实用 程序，然后导出并注入到平台特定的目录文件中的core项中。例如，实现v-bind:class 背后的逻辑的核心就是在 <code>platforms/web/runtime/modules/class.js</code> ——这个入口是在<code>entries/web-runtime.js</code> ，用于创建特定浏览器的vdom的修补功能。</p> <ul><li><code>sfc</code> 包含单文件组件(*.vue)解析逻辑。用到 package 中的 vue-template-compiler 依赖包。</li> <li>包含整个代码库中共享的实用程序。</li></ul></li></ul></div> </div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.da650921.js" defer></script><script src="/assets/js/2.cfea43a3.js" defer></script><script src="/assets/js/94.02ba3e23.js" defer></script>
  </body>
</html>
